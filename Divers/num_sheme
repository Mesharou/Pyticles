Tracking use of numerical schemes...

==> in Pyticles.py: 951

r = run_process(update_xyz)

====>  in Pyticles_subroutines/update_xyz_largemem.py : 201

  partF.timestep_rk4(px_F,py_F,pz_F,u,v,w,itim,fct,dfct,pm_s,pn_s,mask_s,\
                               dz,dt,ng,nq,i0,j0,k0)


====>in Modules/pyticles_3d_sig_sa.F: 1201

    coef = 1./6.

       do ip = 1,min(npmx,np)

         if (.not.(isnan(px(ip)*py(ip)*pz(ip)))) then

           ! Forward Euler / predictor
           CALL advance_3d(px(ip),py(ip),pz(ip),u,v,w,
     & itim,fct,pm,pn,dz,dt,i0,j0,k0,
     & nx,ny,nz,ng,np,dpx(0),dpy(0),dpz(0))

           if (.not.(isnan(dpx(0)*dpy(0)*dpz(0)))) then

           ! backward Euler / corrector
           CALL advance_3d(px(ip)+0.5*dpx(0),py(ip)+0.5*dpy(0),
     & pz(ip)+0.5*dpz(0),
     & u,v,w,itim,fct+0.5*dfct,pm,pn,dz,dt,i0,j0,k0,
     & nx,ny,nz,ng,np,dpx(1),dpy(1),dpz(1))

            if (.not.(isnan(dpx(1)*dpy(1)*dpz(1)))) then

           ! midpoint rule / predictor
           CALL advance_3d(px(ip)+0.5*dpx(1),py(ip)+0.5*dpy(1),
     & pz(ip)+0.5*dpz(1),
     & u,v,w,itim,fct+0.5*dfct,pm,pn,dz,dt,i0,j0,k0,
     & nx,ny,nz,ng,np,dpx(2),dpy(2),dpz(2))

             if (.not.(isnan(dpx(2)*dpy(2)*dpz(2)))) then

           ! Corrector
           CALL advance_3d(px(ip)+dpx(2),py(ip)+dpy(2),
     & pz(ip)+dpz(2),
     & u,v,w,itim,fct+1.*dfct,pm,pn,dz,dt,i0,j0,k0,
     & nx,ny,nz,ng,np,dpx(3),dpy(3),dpz(3))
...
           dpxi(ip) = coef * (dpx(0) + 2 * dpx(1) + 2 * dpx(2) + dpx(3))
           dpyi(ip) = coef * (dpy(0) + 2 * dpy(1) + 2 * dpy(2) + dpy(3))
           dpzi(ip) = coef * (dpz(0) + 2 * dpz(1) + 2 * dpz(2) + dpz(3))


           !write(*,*) 'in RK4',px(ip),py(ip),dpxi(ip),dpyi(ip)
           call check_mask(mask,px(ip),py(ip),dpxi(ip),dpyi(ip)
     & ,ng,npmx,i0,j0,nx,ny)


           px(ip) = px(ip) + dpxi(ip)
           py(ip) = py(ip) + dpyi(ip)
           pz(ip) = pz(ip) + dpzi(ip)

======> in Modules/interp_3d_for_pyticles  advance_3d : 34 

         ... plein d'inerpolations linéraires...
	 En temps ... : 
	 Pour simplifier la compréhension je ne montre que pour U
         - f est l'inerpolation linéaire temporelle de U
         
	   f = fct * u(iu-1:iu+2,j-1:j+2,k-1:k+2,itim(1))
           + (1-fct) * u(iu-1:iu+2,j-1:j+2,k-1:k+2,itim(0))
         
	 - suivi d'une interpolation spatiale linéaire sur pu

	   call interp3(f,pxlu,pyl,pzl,pu) 

	  => in same file : 245

	  subroutine interp3(f,x,y,z,fi)
          ...
          Faut-il faire des modifiactions ici sur la méthode interp3 ? 










